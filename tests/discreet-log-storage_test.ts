// deno-lint-ignore-file require-await no-explicit-any prefer-const
// @ts-ignore
import { Clarinet, Tx, Chain, Account, types, assertEquals, pricePackageToCV, assertStringIncludes, hex2ascii } from "./deps.ts";
// @ts-ignore
import type { PricePackage, Block } from "./deps.ts";

// Unfortunately it is not straightforward to import "../src/stacks-redstone.ts"
// in Clarinet test files. Values are therefore generated by the helper scripts
// found in the ./scripts directory. The parameters used to generate the data
// is provided in comments.

const BTChex = "BTC";
const UUID = "fakeuuid";
const nftAssetContract = "open-dlc";
const dlcManagerContract = "dlc-manager-pricefeed-v1-02";
const callbackContract = "callback-contract";

const contractPrincipal = (deployer: Account, contract: string) => `${deployer.address}.${contract}`;

const trustedOraclePubkey = "0x035ca791fed34bf9e9d54c0ce4b9626e1382cf13daa46aa58b657389c24a751cc6";
const untrustedOraclePubkey = "0x03cd2cfdbd2ad9332828a7a13ef62cb999e063421c708e863a7ffed71fb61c88c9";

const pricePackage: PricePackage = {
    timestamp: 1647332581,
    prices: [{ symbol: "BTC", value: 2.5 }]
}

const pricePackageWrong: PricePackage = {
    timestamp: 1647332581,
    prices: [{ symbol: "ETH", value: 2.5 }]
}

const packageCV = pricePackageToCV(pricePackage);
const wrongPackageCV = pricePackageToCV(pricePackageWrong);
const signature = "0x4ee83f2bdc6d67619e13c5786c42aa66a899cc63229310400247bac0dd22e99454cec834a98b56a5042bcec5e709a76e90d072569e5db855e58e4381d0adb0c201";
const wrongPackageSingature = "0x5cf7810162047b1dd7f9788259431bc971f3be913c5a7875169f78f3a83b7ed662c068fd55000a37c7fcbb3881b31f59d707a5d33163bb7f4280ba43efb48f5800";

function setTrustedOracle(chain: Chain, senderAddress: string): Block {
    return chain.mineBlock([
        Tx.contractCall(dlcManagerContract, "set-trusted-oracle", [trustedOraclePubkey, types.bool(true)], senderAddress),
    ]);
}

function createNewDLC(chain: Chain, deployer: Account, callbackContract: string) {

  const block = chain.mineBlock([
      Tx.contractCall(dlcManagerContract, "create-dlc-internal", [types.buff(UUID), types.buff(BTChex), types.uint(10), types.uint(10), types.principal(callbackContract), types.principal(callbackContract), types.uint(1)], deployer.address)
  ]);

  block.receipts[0].result.expectOk().expectBool(true);
  const createDLCInternalPrintEvent = block.receipts[0].events[0];
  const callbackPrintEvent = block.receipts[0].events[1];
  const mintEvent = block.receipts[0].events[2];
  return { createDLCInternalPrintEvent, callbackPrintEvent, mintEvent };
}

Clarinet.test({
    name: "Contract owner can set trusted oracle",
    async fn(chain: Chain, accounts: Map<string, Account>) {
        const deployer = accounts.get("deployer")!;
        const block = setTrustedOracle(chain, deployer.address);
        const [receipt] = block.receipts;
        receipt.result.expectOk().expectBool(true);
        const trusted = chain.callReadOnlyFn(dlcManagerContract, "is-trusted-oracle", [trustedOraclePubkey], deployer.address);
        const untrusted = chain.callReadOnlyFn(dlcManagerContract, "is-trusted-oracle", [untrustedOraclePubkey], deployer.address);
        trusted.result.expectBool(true);
        untrusted.result.expectBool(false);
    },
});

Clarinet.test({
    name: "create-dlc called from a protocol-contract emits a dlclink event",
    async fn(chain: Chain, accounts: Map<string, Account>) {
        const deployer_2 = accounts.get('deployer_2')!;

        let block = chain.mineBlock([
            Tx.contractCall(contractPrincipal(deployer_2, callbackContract), "create-dlc-request", [types.buff(BTChex), types.uint(20000), types.uint(10), types.uint(10)], deployer_2.address)
        ]);

        block.receipts[0].result.expectOk().expectBool(true);
        const event = block.receipts[0].events[0];

        assertEquals(typeof event, 'object');
        assertEquals(event.type, 'contract_event');
        assertEquals(event.contract_event.topic, "print");
        assertStringIncludes(event.contract_event.value, "asset: 0x425443");
        assertStringIncludes(event.contract_event.value, "strike-price: u20000");
        assertStringIncludes(event.contract_event.value, "creator: " + contractPrincipal(deployer_2, callbackContract));
        assertStringIncludes(event.contract_event.value, 'event-source: "dlclink:create-dlc:v1"');
    },
});


Clarinet.test({
    name: "create-dlc-internal creates a new dlc, prints an event, calls the callback-function and mints an open-dlc nft",
    async fn(chain: Chain, accounts: Map<string, Account>) {
        const deployer = accounts.get('deployer')!;
        const deployer_2 = accounts.get('deployer_2')!;

        const { createDLCInternalPrintEvent, callbackPrintEvent, mintEvent } = createNewDLC(chain, deployer, contractPrincipal(deployer_2, callbackContract));

        let block = chain.mineBlock([
            Tx.contractCall(dlcManagerContract, "get-dlc", [types.buff(UUID)], deployer.address)
        ]);

        assertEquals(typeof createDLCInternalPrintEvent, 'object');
        assertEquals(createDLCInternalPrintEvent.type, 'contract_event');
        assertEquals(createDLCInternalPrintEvent.contract_event.topic, "print");
        assertStringIncludes(createDLCInternalPrintEvent.contract_event.value, 'asset: 0x425443, closing-time: u10, creator: STNHKEPYEPJ8ET55ZZ0M5A34J0R3N5FM2CMMMAZ6.callback-contract, emergency-refund-time: u10, event-source: "dlclink:create-dlc-internal:v1", uuid: 0x66616b6575756964')

        assertEquals(typeof callbackPrintEvent, 'object');
        assertEquals(callbackPrintEvent.type, 'contract_event');
        assertEquals(callbackPrintEvent.contract_event.topic, "print");
        assertStringIncludes(callbackPrintEvent.contract_event.value, 'nonce: u1, uuid: 0x66616b6575756964')

        assertEquals(typeof mintEvent, 'object');
        assertEquals(mintEvent.type, 'nft_mint_event');
        assertEquals(mintEvent.nft_mint_event.asset_identifier.split("::")[1], nftAssetContract);
        assertEquals(mintEvent.nft_mint_event.recipient.split(".")[1], dlcManagerContract);

        const dlc: any = block.receipts[0].result.expectSome().expectTuple();

        assertEquals(hex2ascii(dlc.asset), "BTC");
        assertEquals(hex2ascii(dlc.uuid), "fakeuuid");
        assertEquals(dlc["closing-price"], "none");
        assertEquals(dlc.creator, "STNHKEPYEPJ8ET55ZZ0M5A34J0R3N5FM2CMMMAZ6.callback-contract");
    },
});

Clarinet.test({
    name: "only contract owner can add DLC",
    async fn(chain: Chain, accounts: Map<string, Account>) {
        const deployer_2 = accounts.get('deployer_2')!;
        const wallet_1 = accounts.get('wallet_1')!;

        let block = chain.mineBlock([
            Tx.contractCall(dlcManagerContract, "create-dlc-internal", [types.buff(UUID), types.buff(BTChex), types.uint(10), types.uint(10), types.principal(contractPrincipal(deployer_2, callbackContract)), types.principal(contractPrincipal(deployer_2, callbackContract)), types.uint(1)], wallet_1.address),
        ]);

        const err = block.receipts[0].result.expectErr();
        assertEquals(err, "u2001"); // err-unauthorised
    },
});

Clarinet.test({
  name: "close-dlc emits an event",
  async fn(chain: Chain, accounts: Map<string, Account>) {
      const deployer = accounts.get('deployer')!;
      const deployer_2 = accounts.get('deployer_2')!;

      createNewDLC(chain, deployer, contractPrincipal(deployer_2, callbackContract));

      let block = chain.mineBlock([
          Tx.contractCall(dlcManagerContract, "close-dlc", [types.buff(UUID)], deployer.address),
      ]);

      block.receipts[0].result.expectOk().expectBool(true);
      const event = block.receipts[0].events[0];

      assertEquals(typeof event, 'object');
      assertEquals(event.type, 'contract_event');
      assertEquals(event.contract_event.topic, "print");
      assertStringIncludes(event.contract_event.value, "uuid: 0x66616b6575756964");
      assertStringIncludes(event.contract_event.value, "asset: 0x425443");
      assertStringIncludes(event.contract_event.value, 'event-source: "dlclink:close-dlc:v1"');
  },
});

Clarinet.test({
  name: "early-close-dlc emits an event",
  async fn(chain: Chain, accounts: Map<string, Account>) {
      const deployer = accounts.get('deployer')!;
      const deployer_2 = accounts.get('deployer_2')!;

      createNewDLC(chain, deployer, contractPrincipal(deployer_2, callbackContract));

      let block = chain.mineBlock([
          Tx.contractCall(dlcManagerContract, "early-close-dlc", [types.buff(UUID)], deployer.address),
      ]);

      block.receipts[0].result.expectOk().expectBool(true);
      const event = block.receipts[0].events[0];

      assertEquals(typeof event, 'object');
      assertEquals(event.type, 'contract_event');
      assertEquals(event.contract_event.topic, "print");
      assertStringIncludes(event.contract_event.value, "uuid: 0x66616b6575756964");
      assertStringIncludes(event.contract_event.value, "asset: 0x425443");assertStringIncludes(event.contract_event.value, 'event-source: "dlclink:early-close-dlc:v1"');
  },
});

Clarinet.test({
  name: "only contract deployer call early-close-dlc",
  async fn(chain: Chain, accounts: Map<string, Account>) {
      const deployer = accounts.get('deployer')!;
      const wallet_1 = accounts.get('wallet_1')!;
      const deployer_2 = accounts.get('deployer_2')!;

      createNewDLC(chain, deployer, contractPrincipal(deployer_2, callbackContract));

      let block = chain.mineBlock([
          Tx.contractCall(dlcManagerContract, "early-close-dlc", [types.buff(UUID)], wallet_1.address),
      ]);

      const err = block.receipts[0].result.expectErr();
      assertEquals(err, "u2001"); // err-unathorized
  },
});

Clarinet.test({
    name: "close-dlc-internal updates closing-price and actual-closing-time and burns the corresponding nft",
    async fn(chain: Chain, accounts: Map<string, Account>) {
        const deployer = accounts.get('deployer')!;
        const deployer_2 = accounts.get('deployer_2')!;
  
        createNewDLC(chain, deployer, contractPrincipal(deployer_2, callbackContract));
        setTrustedOracle(chain, deployer.address);

        let block = chain.mineBlock([
            Tx.contractCall(dlcManagerContract, "close-dlc-internal", [types.buff(UUID), packageCV.timestamp, packageCV.prices, signature], deployer.address),
            Tx.contractCall(dlcManagerContract, "get-dlc", [types.buff(UUID)], deployer.address)
        ]);

        block.receipts[0].result.expectOk().expectBool(true);
        const printEvent2 = block.receipts[0].events[0];

        assertEquals(typeof printEvent2, 'object');
        assertEquals(printEvent2.type, 'contract_event');
        assertEquals(printEvent2.contract_event.topic, "print");
        assertStringIncludes(printEvent2.contract_event.value, 'actual-closing-time: u1647332, closing-price: (some u250000000), event-source: "dlclink:close-dlc-internal:v1", uuid: 0x66616b6575756964')

        const burnEvent = block.receipts[0].events[1];

        assertEquals(typeof burnEvent, 'object');
        assertEquals(burnEvent.type, 'nft_burn_event');
        assertEquals(burnEvent.nft_burn_event.asset_identifier.split("::")[1], nftAssetContract);
        assertEquals(burnEvent.nft_burn_event.sender.split(".")[1], dlcManagerContract);

        const dlc: any = block.receipts[1].result.expectSome().expectTuple();
        assertEquals(dlc['closing-price'], "(some u250000000)")
    },
});

Clarinet.test({
    name: "can't close a dlc with wrong asset submitted",
    async fn(chain: Chain, accounts: Map<string, Account>) {
        const deployer = accounts.get('deployer')!;
        const deployer_2 = accounts.get('deployer_2')!;
  
        createNewDLC(chain, deployer, contractPrincipal(deployer_2, callbackContract));
        setTrustedOracle(chain, deployer.address);

        let block = chain.mineBlock([
            Tx.contractCall(dlcManagerContract, "close-dlc-internal", [types.buff(UUID), wrongPackageCV.timestamp, wrongPackageCV.prices, wrongPackageSingature], deployer.address),
        ]);

        const err = block.receipts[0].result.expectErr();
        assertEquals(err, "u2008"); // err-not-the-same-assets
    },
});

Clarinet.test({
    name: "can't request close on a closed dlc",
    async fn(chain: Chain, accounts: Map<string, Account>) {
        const deployer = accounts.get('deployer')!;
        const deployer_2 = accounts.get('deployer_2')!;
  
        createNewDLC(chain, deployer, contractPrincipal(deployer_2, callbackContract));
        setTrustedOracle(chain, deployer.address);

        let block = chain.mineBlock([
            Tx.contractCall(dlcManagerContract, "close-dlc-internal", [types.buff(UUID), packageCV.timestamp, packageCV.prices, signature], deployer.address),
            Tx.contractCall(dlcManagerContract, "close-dlc", [types.buff(UUID)], deployer.address),
        ]);

        const err = block.receipts[1].result.expectErr();
        assertEquals(err, "u2005"); // err-already-closed
    },
});

Clarinet.test({
    name: "only authorized wallets can request close-dlc",
    async fn(chain: Chain, accounts: Map<string, Account>) {
        const deployer = accounts.get('deployer')!;
        const wallet_1 = accounts.get('wallet_1')!;
        const deployer_2 = accounts.get('deployer_2')!;
  
        createNewDLC(chain, deployer, contractPrincipal(deployer_2, callbackContract));
        setTrustedOracle(chain, deployer.address);

        let block = chain.mineBlock([
            Tx.contractCall(dlcManagerContract, "close-dlc", [types.buff(UUID)], wallet_1.address),
        ]);

        const err = block.receipts[0].result.expectErr();
        assertEquals(err, "u2001"); // err-already-closed
    },
});



Clarinet.test({
    name: "get-dlc-closing-price-and-time throws u2007 of not closed",
    async fn(chain: Chain, accounts: Map<string, Account>) {
        const deployer = accounts.get('deployer')!;
        const wallet_1 = accounts.get('wallet_1')!;
        const deployer_2 = accounts.get('deployer_2')!;
  
        createNewDLC(chain, deployer, contractPrincipal(deployer_2, callbackContract));

        let block = chain.mineBlock([
            Tx.contractCall(dlcManagerContract, "get-dlc-closing-price-and-time", [types.buff(UUID)], wallet_1.address),
        ]);

        const err = block.receipts[0].result.expectErr();
        assertEquals(err, "u2007"); // err-already-closed
    },
});

Clarinet.test({
    name: "get-dlc-closing-price-and-time returns correct closing-price for closed DLC",
    async fn(chain: Chain, accounts: Map<string, Account>) {
        const deployer = accounts.get('deployer')!;
        const wallet_1 = accounts.get('wallet_1')!;
        const deployer_2 = accounts.get('deployer_2')!;
  
        createNewDLC(chain, deployer, contractPrincipal(deployer_2, callbackContract));

        setTrustedOracle(chain, deployer.address);

        let block = chain.mineBlock([
            Tx.contractCall(dlcManagerContract, "close-dlc-internal", [types.buff(UUID), packageCV.timestamp, packageCV.prices, signature], deployer.address),
            Tx.contractCall(dlcManagerContract, "get-dlc-closing-price-and-time", [types.buff(UUID)], wallet_1.address),
        ]);

        const partialDLC: any = block.receipts[1].result.expectOk().expectTuple();
        assertEquals(partialDLC["closing-price"], "(some u250000000)");
        assertEquals(partialDLC["closing-time"], "u10")
    },
});
